import { SourceNode } from 'source-map';
import { ChunkList, tagToJS, format } from './utils';
import { ElementStats } from './node-stats';

/**
 * Template compiler scope
 */

export enum RuntimeSymbols {
    get, mountBlock, updateBlock, mountIterator, updateIterator, mountKeyIterator,
    updateKeyIterator, createInjector, block, enterScope, exitScope, getScope,
    getProp, getState, getVar, setVar, setAttribute, updateAttribute, updateProps,
    addClass, finalizeAttributes, finalizeProps, addEvent, addStaticEvent, finalizeEvents,
    getEventHandler, callEventHandler, renderSlot, setRef, setStaticRef, finalizeRefs, createComponent,
    mountComponent, updateComponent, unmountComponent, mountInnerHTML, updateInnerHTML,
    elem, elemWithText, text, updateText, filter, insert
}

interface CompileScopeOptions {
    /** Path to JS module that holds Endorphin runtime functions */
    module?: string;

    /** Symbol for referencing host component of the rendered template */
    host?: string;

    /** Symbol for referencing local scope of rendered component */
    scope?: string;

    /** Name of component being compiled, must be in CamelCase */
    component?: string;

    /** Characters for one level of indentation */
    indent?: string;

    /** Prefix for generated top-level module symbols */
    prefix?: string;

    /** Suffix for generated top-level module symbols */
    suffix?: string;
}

interface ElementContext {
    /** Name of parent element symbol (element or injector) */
    symbol: string;

    /** Element stats */
    stats: ElementStats;

    /** Name of injector instance bound to element. */
    injector?: string;

    /** Output source node for runtime code, required to properly setup element context */
    output: SourceNode;

    parent?: ElementContext;
}

interface TemplateContext {
    update: ChunkList;
    parent?: TemplateContext;
    localSymbols: SymbolGenerator;

    /** Name of generated function */
    symbol: string;

    /** Output source node for runtime code, required to properly setup element context */
    output: SourceNode;

    /** Injector symbol for parent context */
    injector?: string;

    /** Context of element output */
    element?: ElementContext;
}

export const defaultOptions: CompileScopeOptions = {
    host: 'host',
    scope: 'scope',
    indent: '\t',
    prefix: '$$',
    suffix: '',
    module: '@endorphinjs/endorphin',
    component: ''
}

export default class CompileScope {
    /** Endorphin runtime symbols required by compiled template */
    runtimeSymbols: Set<RuntimeSymbols> = new Set();

    /** Template symbols, used to store and update data generated by template */
    private readonly scopeSymbols: SymbolGenerator;

    /** Top-level JS module symbols */
    private readonly globalSymbols: SymbolGenerator;

    /** Context of currently rendered template */
    template?: TemplateContext;

    readonly options: CompileScopeOptions;

    /** Contents of compiled template */
    readonly body: SourceNode[] = [];

    constructor(options?: CompileScopeOptions) {
        this.options = Object.assign({}, defaultOptions, options);
        const suffix = tagToJS(this.options.component || '', true) + (this.options.suffix || '');

        this.scopeSymbols = new SymbolGenerator(`${this.scope}.$_`);
        this.globalSymbols = new SymbolGenerator(this.options.prefix, num => suffix + num);
    }

    /** Symbol for referencing host component of the rendered template */
    get host(): string {
        return this.options.host;
    }

    /** Symbol for referencing local scope */
    get scope(): string {
        return this.options.scope;
    }

    /** Path to JS module that holds Endorphin runtime functions */
    get module(): string {
        return this.options.module;
    }

    /** Current indentation token */
    get indent(): string {
        return this.options.indent;
    }

    get element(): ElementContext {
        return this.template.element;
    }

    /**
     * Marks given runtime symbol as used by template and returns its string
     * representation
     * @param symbol
     */
    use(symbol: RuntimeSymbols): string {
        this.runtimeSymbols.add(symbol);
        return RuntimeSymbols[symbol];
    }

    /**
     * Creates scope symbol with given name
     */
    scopeSymbol(name: string): string {
        return this.scopeSymbols.generate(name);
    }

    /**
     * Creates global JS module symbol
     */
    globalSymbol(name: string): string {
        return this.globalSymbols.generate(name);
    }

    /**
     * Creates symbol, local to currently rendered JS function
     */
    localSymbol(name: string): string {
        return this.template.localSymbols.generate(name);
    }

    /**
     * Push given source node as content of compiled file
     */
    push(node: SourceNode): void {
        this.body.push(node);
    }

    enterFunction(name: string, injectorSymbol?: string): string {
        const ctx: TemplateContext = {
            symbol: this.globalSymbol(name),
            localSymbols: new SymbolGenerator(),
            injector: injectorSymbol,
            parent: this.template,
            output: new SourceNode(),
            update: []
        };
        this.template = ctx;
        return ctx.symbol;
    }

    exitFunction(body: ChunkList): SourceNode {
        const output = new SourceNode();
        const { template, indent } = this;
        const args = `${this.host}${template.injector ? `, ${template.injector}` : ''}, ${this.scope}`;

        output.add(`function ${template.symbol}(${args}) {\n${indent}`);
        output.add(format(body, indent));

        if (template.update.length) {
            // Generate update function for rendered template
            const updateSymbol = `${template.symbol}Update`;
            output.add(`\n${indent}return ${updateSymbol};\n}\n\n`);
            output.add(`function ${updateSymbol}(${args}) {\n${indent}`);
            output.add(format(template.update, indent));
            output.add(`\n}\n`);
        } else {
            output.add(`\n}\n`);
        }

        this.template = this.template.parent;
        return output;
    }

    enterElement(symbol: string, stats: ElementStats): SourceNode {
        const ctx: ElementContext = {
            stats,
            symbol,
            output: new SourceNode(),
            parent: this.template.element
        };

        this.template.element = ctx;
        return ctx.output;
    }

    exitElement(): ChunkList {
        // Finalize element
        const chunks: ChunkList = [];
        const { element } = this.template;

        // TODO finalize all data types
        if (element.stats.attributeExpressions || element.stats.dynamicAttributes.size) {
            chunks.push(`${this.use(RuntimeSymbols.finalizeAttributes)}(${element.symbol});`);
        }

        this.template.element = element.parent;
        return chunks;
    }

    /**
     * Check if content must be inserted via injector at current context
     */
    requiresInjector(): boolean {
        const { element } = this;
        return element ? !element.stats.staticContent : !!this.template.injector;
    }

    /**
     * Returns injector instance symbol for context element
     */
    injector(): string {
        const { element } = this;
        if (element) {
            if (!element.injector) {
                const symbol = element.injector = this.scopeSymbol('injector');
                element.output.add(`${symbol} = ${this.use(RuntimeSymbols.createInjector)}(${element.symbol});`);
            }

            return element.injector;
        }

        return this.template.injector;
    }
}

interface SymbolPartGenerator {
    (num: number): number | string
}

const numGenerator: SymbolPartGenerator = num => num;

class SymbolGenerator {
    _symbols: {
        [prefix: string]: number
    };
    constructor(readonly prefix: string | SymbolPartGenerator = '', readonly suffix: string | SymbolPartGenerator = numGenerator) {
        this._symbols = {};
    }

    /**
     * Generates symbol with given name
     * @param name
     */
    generate(name: string): string {
        if (name in this._symbols) {
            this._symbols[name]++;
        } else {
            this._symbols[name] = 0;
        }

        const num = this._symbols[name];

        return this._getPart(num, this.prefix) + name + this._getPart(num, this.suffix);
    }

    _getPart(num: number, generator: string | SymbolPartGenerator): number | string {
        if (typeof generator === 'function') {
            return generator(num);
        } else if (typeof generator === 'string') {
            return generator;
        }

        return '';
    }
}
